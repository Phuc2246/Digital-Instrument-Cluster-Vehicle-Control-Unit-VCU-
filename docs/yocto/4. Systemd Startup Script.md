# Systemd Startup Script

This document describes a custom **systemd startup service** in a Yocto-based Linux image to automatically:
- bring up **CAN interface (can0)** at boot, and
- launch a **Qt application** using **EGLFS**.

Project structure (Yocto layer layout):

```

meta-phuc/
└── recipes-core/
└── startup/
├── files/
│   ├── mystartup.sh
│   └── my-startup.service
└── startup_1.0.bb

````

---

## 1. mystartup.sh (recipes-core/startup/files/mystartup.sh)

```sh
#!/bin/sh

LOGFILE=/var/log/startup.log
echo "[$(date '+%Y-%m-%d %H:%M:%S')] Starting custom startup script" >> "$LOGFILE"

# Bring up CAN0 at 50 kbps
echo "[$(date '+%H:%M:%S')] Bringing up can0 at 50kbps..." >> "$LOGFILE"
ip link set can0 down 2>/dev/null
ip link set can0 type can bitrate 50000
ip link set can0 up

if [ $? -eq 0 ]; then
    echo "[$(date '+%H:%M:%S')] can0 up OK (50kbps)" >> "$LOGFILE"
else
    echo "[$(date '+%H:%M:%S')] ERROR: failed to bring up can0" >> "$LOGFILE"
fi

# Start Qt application (EGLFS)
echo "[$(date '+%H:%M:%S')] Starting Qt app..." >> "$LOGFILE"
export QT_QPA_PLATFORM=eglfs
exec /usr/bin/project1
````

Make it executable:

```bash
chmod +x mystartup.sh
```

### What this script does

1. **Logging**

   * Appends timestamps and status messages to `/var/log/startup.log`.
   * Helps debug boot-time issues (CAN not up, Qt app not starting, etc.).

2. **CAN initialization (can0 @ 50 kbps)**

   * Brings the interface down first to avoid “already up” configuration errors:

     * `ip link set can0 down`
   * Configures CAN bitrate:

     * `ip link set can0 type can bitrate 50000`
   * Brings the interface up:

     * `ip link set can0 up`
   * Checks the return code (`$?`) and logs success/failure.

3. **Qt auto-start (EGLFS backend)**

   * Sets `QT_QPA_PLATFORM=eglfs` to run Qt directly on framebuffer/DRM (no desktop needed).
   * Uses `exec /usr/bin/project1` so the Qt app replaces the shell process (service “becomes” the app).

---

## 2. my-startup.service (recipes-core/startup/files/my-startup.service)

```ini
[Unit]
Description=Custom startup commands (CAN + Qt)
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/mystartup.sh
Restart=no

[Install]
WantedBy=multi-user.target
```

### `[Unit]` section

```ini
Description=Custom startup commands (CAN + Qt)
```

* Human-readable description (visible in `systemctl status`).

```ini
After=network.target
```

* Starts after the basic network target is reached.
* In this project, it mainly ensures the system is past early boot before running CAN + Qt setup.

---

### `[Service]` section

```ini
Type=simple
```

* The default systemd service type for a long-running foreground process.
* This fits well because your script ends with `exec /usr/bin/project1`, so the service becomes the Qt app process.

```ini
ExecStart=/usr/bin/mystartup.sh
```

* Runs your startup script located in `/usr/bin/`.

```ini
Restart=no
```

* systemd will **not** restart the service if it exits or crashes.
* (If you later want auto-restart when Qt crashes, you can change this to `Restart=on-failure`.)

---

### `[Install]` section

```ini
WantedBy=multi-user.target
```

* Enables the service to start automatically during normal multi-user boot.

---

## 3. BitBake recipe (startup_1.0.bb)

Your recipe should install:

* `mystartup.sh` into `/usr/bin/`
* `my-startup.service` into the systemd unit directory
* and enable the service automatically.

Example recipe:

```bitbake
DESCRIPTION = "Custom startup script and systemd service (CAN + Qt)"
LICENSE = "CLOSED"

SRC_URI += "file://my-startup.service \
            file://mystartup.sh"

inherit systemd

S = "${WORKDIR}"

do_install() {
    # install script
    install -d ${D}${bindir}
    install -m 0755 ${WORKDIR}/mystartup.sh ${D}${bindir}/mystartup.sh

    # install systemd unit
    install -d ${D}${systemd_system_unitdir}
    install -m 0644 ${WORKDIR}/my-startup.service \
        ${D}${systemd_system_unitdir}/my-startup.service
}

FILES:${PN} += "${systemd_system_unitdir}/my-startup.service"

SYSTEMD_SERVICE:${PN} = "my-startup.service"
SYSTEMD_AUTO_ENABLE = "enable"
```

---

## 4. Add to IMAGE_INSTALL

In your `local.conf` or image recipe:

```bitbake
INIT_MANAGER = "systemd"
IMAGE_INSTALL:append = " startup"
```

Rebuild your image:

```bash
bitbake <your-image>
```

---

## 5. Verification on target

Check service status:

```bash
systemctl status my-startup.service
journalctl -u my-startup.service -b
```

Check CAN:

```bash
ip link show can0
candump can0
```

Check startup logs:

```bash
cat /var/log/startup.log
```

```
```
